## 프로젝트에서 트랜잭션 분리의 필요성을 느낀 배경

프로젝트에서 메시지 전송 기능에 알림 기능을 도입하면서 알림 전송 실패로 인해 메시지 전송트랜잭션이 롤백되는 상황이 발생했습니다. 비즈니스 중요도를 고려하면 사용자의 편의를 위한 부가적인 알림 기능이 메시지 전송이라는 메인 서비스에 영향을 미치는 것이 부자연스럽다고 판단해 트랜잭션 분리를 고려하게 되었습니다.

먼저 서비스 코드는 다음과 같습니다.

```java
// Message Service
@Transactional
public void sendMessage(final MessageDto messsageDto)  {
	final Message message = messageDto.toEntity();
	messageRepository.save(message); // 전송한 메시지 저장

	try {
			final NotificationMessageDto dto = NotificationMessageDto.from(message);
			notificationService.send(); // 알림 전송
    } catch (final Exception ex) {
    }
}

```

```java
// Notification Service
@Transactional
public void send(final NotificationMessageDto notificationMessageDto) {
	// 기기 토큰 조회 로직 생략

	// FCM 알림 전송 API용 Message DTO
	final Message messageNotificationDto = Message.builder()
												  .setToken(deviceToken.getDeviceToken())
												  .putData("image", notificationMessageDto.image())
												  .putData("body", notificationMessageDto.body())
												  .build();
	// 알림 전송 API 요청
	firebaseMessaging.send(message);
}

```

문제가 되었던 부분은 `NotificationService`에서 알림 전송용 DTO인 `Message` 생성 중 알림에 포함될 이미지를 대입하는 `.putData("image", notificationMessageDto.image())` 부분입니다. `Message` DTO의 모든 필드에는 `@NonNull` 어노테이션이 붙어있었고, 따라서 null을 포함하면 안 되는 DTO였습니다. 그런데 알림 전송에 포함될 이미지가 등록되지 않은 경우 해당 필드에 null을 전달하고 있어 NPE 예외가 발생한 것입니다. 이로 인해 메시지 트랜잭션 롤백으로 이어지게 되었습니다.

그런데 의문이 생기는 점은 분명 메시지 서비스에서 알림 서비스 로직을 모두 try-catch로 묶어주었고, catch문에서는 모든 예외에 대한 핸들링이 가능하도록 `Exception`을 받고 있음에도 메시지 전송 트랜잭션이 롤백되어 메시지 전송이 불가능한 이슈로 이어진다는 것이었습니다.

해당 문제가 발생한 이유는 메시지 전송 트랜잭션과 알림 전송 트랜잭션이 분리되지 않았기 때문입니다. `NotificationService` 의 `send()` 메서드는 `@Transactional` 어노테이션을 가지고 있고, 전파 옵션은 디폴트인 `propagation = Propagation.REQUIRED`로 지정되어 있습니다. 따라서 `NotificationService` 의 `send()` 메서드는 `MessageService`의 `sendMessage()` 트랜잭션에 참여하게 되고, 두 트랜잭션은 하나의 물리 트랜잭션으로 묶이게 됩니다. 이때 동일한 물리 트랜잭션에는 같은 롤백 규칙이 적용되는데, RuntimeException 롤백 규칙의 기본값은

내부 트랜잭션에서 RuntimeException인 NPE가 발생하면서 `rollback-only` 마킹을 합니다. 따라서 `MessageService`의 `sendMessage()`의 트랜잭션에서 예외가 발생하지 않았지만 해당 트랜잭션이 완료되는 시점에 `rollback-only` 마킹으로 인해 최종적으로 물리 트랜잭션이 롤백되는 것입니다.

이 부분은 문제 상황의 배경을 설명하기 위한 개념이므로 자세한 내용은 다양한 테스트와 함께  상황이 잘 정리되어 있는 [우아한형제들의 기술 블로그](https://techblog.woowahan.com/2606/)를 확인해보시면 좋을 것 같습니다.

결론은 다음과 같습니다.

1. 메시지 전송이 알림 기능에 의한 영향을 받지 않도록 하기 위해 try-catch를 사용해 알림 기능에서 발생하는 예외의 영향을 분리하고자 시도
2. 두 서비스의 트랜잭션이 하나의 물리 트랜잭션으로 묶이면서 RuntimeException 발생 시 물리 트랜잭션에 참여한 모든 논리 트랜잭션이 롤백되는 문제 발생
3. 두 서비스 메서드 트랜잭션 분리의 필요성을 느낌

## 트랜잭션 분리를 위한 시도

`MessageService` 와 `NotificationService` 메서드의 트랜잭션을 분리하기 위해 고민하던 중 두 서비스는 비즈니스적으로 독립적인 서비스라고 판단했습니다. 앞서 언급한 것처럼 알림 서비스는 사용자 편의성을 위한 부가적인 기능이라는 점에서, 메시지를 저장하는 핵심 기능에 영향을 미치면 안되기 때문입니다.
사용자의 입장에서 생각해보면 메시지를 정상적으로 전송 완료 했는데, 전송한 메시지에 대한 알림이 전송 실패했다는 이유로 내가 전송한 메시지에까지 문제가 발생한다면 이상하다고 느끼게 되겠지요.
따라서 메시지 전송과 알림 전송은 트랜잭션 뿐만 아니라 서비스도 분리되어야 한다고 판단해 트랜잭션을 분리하는 과정에서 스프링 이벤트를 사용해 두 서비스의 의존성을 분리해주었습니다. 하지만 의존성을 분리해주었다고 트랜잭션이 분리된 것은 아니기 때문에 트랜잭션을 분리하기 위한 방법도 고려해야하므로 스프링 이벤트를 사용하면서 트랜잭션을 분리할 수 있는 방법들을 고민하게 되었습니다.

## 첫 번째 시도

```java
@EventListener
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void sendNotification(final NotificationEvent notificationEvent) {
	try {
		notificationService.sendNotification(notificationEvent);
	} catch (final Exception exception) {
		log.error("exception type : {}, ", ex.getClass().getSimpleName(), ex);
	}
}

```

처음에는 단순히 `@EventListener`를 사용해 이벤트를 처리하고, 트랜잭션 전파 옵션을 사용해 이벤트 발행 트랜잭션과 이벤트 수행 트랜잭션을 분리해주는 방식을 고려했습니다.

트랜잭션 전파 옵션 중 `Propagation.REQUIRES_NEW`를 사용하면 트랜잭션을 물리적으로 분리하게 됩니다. 따라서 이벤트 리스너에서 호출하는 `NotificationService`는 `MessageService`의 트랜잭션과 다른 커넥션을 갖게 되어 물리적으로 분리되고, 따라서 `NotificationService` 트랜잭션의 커밋이나 롤백 여부와 관계 없이 `MessageService`의 트랜잭션은 독립적으로 동작할 수 있게 됩니다.

(물리 트랜잭션과 논리 트랜잭션에 대한 이해가 필요하다면 [블로그](https://mangkyu.tistory.com/269)를 참고해주세요.)

참고로 물리적인 트랜잭션이 분리되었다고 하더라도 내부 트랜잭션에서 예외에 대한 핸들링이 되지 않을 경우 발생한 예외로 인해 외부 트랜잭션까지 롤백될 수 있다는 점을 고려해 try-catch문을 이용한 예외 핸들링 작업은 필요합니다.

**주의할 점**

`Propagation.REQUIRES_NEW`를 사용하는 경우 데드락이 발생할 수 있다는 점을 주의해야 합니다. 앞서 언급한 것처럼 `Propagation.REQUIRES_NEW`를 사용하는 것은 새로운 커넥션을 한 개 더 할당받는 물리적인 트랜잭션의 분리입니다. 커넥션을 새롭게 할당 받아 새로운 트랜잭션을 시작하고 트랜잭션이 종료될 때까지 기존 트랜잭션은 대기하게됩니다. 즉, `Propagation.REQUIRES_NEW`를 사용하면 기존 트랜잭션이 종료되지 않은 상태에서 새로운 커넥션을 할당받기 때문에 `메시지 전송`이라는 하나의 요청에서 두 개의 커넥션을 점유하게 되는 것입니다. 이로 인해 데드락이 발생할 가능성이 생깁니다.

예를 들어 아래 그림과 같이 HikariCP의 max-pool-size가 2라고 가정해봅시다.

<img alt="deadlock" height="200" src="/images/deadlock.png" width="300"/>

이때 두 개의 스레드가 동시에 `messageService.send()`를 요청해 각 스레드 별로 한 개의 커넥션을 점유하게 된 경우, 모든 커넥션은 사용중인 상태가 됩니다. 그리고 각 스레드는 `notificationService.sendNotification()`를 수행하기 위해 새로운 커넥션이 필요합니다. 그런데 더이상 사용 가능한 커넥션이 없기 때문에 각 스레드는 커넥션이 반납될 때까지 대기하게 됩니다. 그런데 메시지 전송 요청이 트랜잭션을 종료하고 커넥션을 반납하기 위해서는 알림 전송 요청 트랜잭션이 완료되어야합니다. 즉, 두 개의 스레드는 이미 커넥션을 하나씩 점유하고 있는 상황에서 다른 커넥션이 종료되기만을 기다리고 있는데, 두 스레드 모두 새로운 커넥션이 있어야만 커넥션을 반납할 수 있는 상황인 것입니다. 그리고 이처럼 모든 스레드가 커넥션을 반납하기 위해 다른 커넥션이 필요한 상황에서, 어떤 스레드도 커넥션을 반납할 수 없는 상황이 '데드락'입니다.

## 두 번째 시도

```java
@Async
@EventListener
public void sendNotification(final NotificationEvent notificationEvent) {
	try {
		notificationService.sendNotification(notificationEvent);
	} catch (final Exception exception) {
		log.error("exception type : {}, ", ex.getClass().getSimpleName(), ex);
	}
}

```

첫 번째 방법으로는 새로운 트랜잭션과 기존 트랜잭션을 확실하게 분리해줄 수 있었지만 문제는 데드락이 발생할 수 있다는 점이었습니다. 어떻게 하면 데드락 문제를 피하면서 트랜잭션을 분리해줄 수 있을까요?

정답은 `@Async` 어노테이션을 사용하는 것입니다. `@Async`를 사용한 메서드는 스레드가 분리되어 비동기적으로 작업을 수행하게됩니다. 비동기적으로 작업을 수행한다는 것은 기존 트랜잭션인 메시지 전송 트랜잭션이 더이상 알림 전송 트랜잭션이 완료될 때까지 기다리지 않고, 각 작업이 병렬적으로 수행된다는 의미입니다. 여기서 주목할 부분은 '기다리지 않는다는 것'입니다. 새로운 트랜잭션이 독립적인 스레드에서 수행되기 때문에 특정 스레드가 커넥션을 점유하면서 또 다른 커넥션을 기다리지 않게 되고, 따라서 데드락이 발생하지 않게 되는 것입니다.
이때 새로운 스레드를 생성하면 무조건 새로운 커넥션을 할당받기 때문에 자연스럽게 트랜잭션이 분리되어 트랜잭션 전파 속성을 사용한 트랜잭션 분리가 불필요하게 됩니다.

**주의할 점**

하지만 '비동기'로 처리된다는 것은 항상 순서에 주의해야 한다는 것을 의미합니다. 이벤트를 발행할 때 하나의 스레드를 생성해 병렬적으로 작업을 진행하기 때문에 동기적으로 수행되어야 하는 로직에는 적절하지 않습니다.

예를 들어 위의 예제의 경우에는 `MessaggeService`에서 전송된 메시지를 DB에 저장한 이후 알림을 전송해야 합니다. 그런데 만약 전송한 메시지 저장과 메시지 알림 전송이 비동기로 수행된다면 메시지가 DB에 정상적으로 commit되기 이전에 알림이 먼저 전송될 가능성이 있습니다. 이때 알림이 이미 사용자에게 전송된 이후 메시지 전송 트랜잭션에 문제가 발생해 트랜잭션이 rollback된다면 이미 사용자는 메시지가 전송되었다는 알림을 받은 상황에서 DB에는 정작 메시지가 저장되지 않는 상황이 발생합니다. 따라서 사용자는 메시지 전송 알림을 확인한 뒤 메시지를 확인하려고 하는데, DB에 저장된 메시지가 없어 메시지를 정상적으로 조회할 수 없는 문제가 발생합니다.

따라서 비즈니스 로직에 맞춰 기능이 비동기로 수행될 수 있는 작업인지 판단해 적절하게 `@Async`를 사용해야 합니다.

(`@Async`를 사용할 때는 `Application`에 `@EnableAsync` 어노테이션을 추가해 비동기를 활성화시켜주어야 합니다.)

## 세 번째 시도

```java
@TransactionalEventListener
public void sendNotification(final NotificationEvent notificationEvent) {
    // 이벤트 처리 생략
}

```

이벤트 리스너 코드를 리뷰해주던 팀원이 질문을 한 개 던져주었습니다.

> 해당 이벤트리스너 메서드는 DB에 저장된 이후에 동작해야 할 것 같은데, 이에 대해서 고려했는지 궁금합니다!
>

트랜잭션 커밋 순서와 관련된 것인데요.
비즈니스 로직을 고려했을 때, 메시지 전송 트랜잭션이 정상적으로 commit된 이후에 메시지 알림을 전송하는 순서를 보장하고 싶습니다. 그런데 앞서 언급한 `@EventListener`와  `@Async`를 사용한 경우에는 순서를 보장할 수 없고, `@EventListener`와 `@Transactional(propagation = Propagation.REQUIRES_NEW)`를 사용했을 때는 데드락이 발생할 수 있다는 문제점이 있습니다.

`메시지 전송 → 알림 전송`의 순서를 보장하면서도 두 개의 트랜잭션을 안전하게 분리해줄 수 있는 방법은 없을까요?

이때 사용할 수 있는 것이 `@TransactionalEventListener`입니다. `@TransactionalEventListener`는 이벤트 리스너의 실행 시점을 지정해줄 수 있습니다. 기본값은 `AFTER_COMMIT`으로, 말 그대로 이벤트 리스너의 실행 시점이 기존 트랜잭션의 commit이 완료된 이후라는 의미입니다. 이렇게 된다면 기존 트랜잭션인 메시지 전송 트랜잭션이 DB에 commit된 이후에 알림 전송을 수행하는 순서를 보장할 수 있습니다.

따라서 트랜잭션 commit이 완료된 상태이기 때문에 이후의 로직에서 예외가 발생하더라도 이미 commit된 트랜잭션에는 영향을 미치지 않습니다. 한 번 DB에 commit되거나 rollback된 트랜잭션의 상태는 더이상 변경할 수 없기 때문입니다. 따라서 트랜잭션 전파 속성을 사용하지 않고도 기존 트랜잭션과 이벤트 리스너의 트랜잭션을 분리할 수 있게 됩니다.

**주의할 점**

현재 저의 코드에서는 `@TransactionalEventListener`만으로도 목표했던 트랜잭션 분리가 가능해집니다. 그러나 해당 어노테이션은 DB 쓰기 작업이 수행되는 로직에는 적절하지 않습니다.

먼저 간단한 테스트코드로 테스트해본 결과를 확인해보겠습니다.

아래 코드와 같이 `@TransactionalEventListener` 이벤트 리스너에 새로운 `EventEntity`를 DB에 저장하는 로직이 있습니다. 해당 알림 전송 기록은 정상적으로 저장되지 않는 것을 확인할 수 있습니다.

```java
// 이벤트 발행
@Transactional
public void publishTransactionalEventListener() {
    eventPublisher.publishEvent(new MyTransactionalEventListenerEvent("my transactional event listener"));
}
```

```java
// 이벤트 리스너
@TransactionalEventListener
@Transactional(propagation = Propagation.REQUIRED)
public void handleTransactionalEventListener(final MyTransactionalEventListenerEvent event) {
    final EventEntity eventEntity = new EventEntity(event.getValue()); // name 필드에 "publish transactional event listener" 저장
    eventListenerRepository.save(eventEntity); // DB 쓰기 작업
}

```

```java
// 이벤트
@Entity
public class EventEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;

		// 생성자, getter 생략
}
```

```java
// 이벤트 리스너에서 DB에 저장한 내역 확인
@Test
void transactional_event_listener_에서_REQUIRED인경우_DB쓰기_작업이_불가능하다() {
    myService.publishTransactionalEventListener();

    assertThat(repository.findByName("my transactional event listener"))
            .isNotNull();
}
```

아래와 같은 예외가 발생하며 테스트가 실패하는 것을 확인할 수 있습니다.

```bash
Expecting actual not to be null
java.lang.AssertionError: 
Expecting actual not to be null
	at transaction.stage3.MyServiceTest.transactional_event_listener_에서_REQUIRED인경우_DB쓰기_작업이_불가능하다(MyServiceTest.java:40)

... 생략
```

### `@TransactionalEventListener`에서만 DB 쓰기 작업이 안되는 이유

> 해당 섹션은 저의 궁금증으로 `@TransactionalEventListener`의 동작 원리를 디버깅하며 학습한 내용입니다. 해당 부분을 알지 못하더라도 `@TransactionalEventListener`을 사용하는 데는 아무 문제가 없으며, 저처럼 해당 어노테이션의 동작 원리가 궁금해진 분들께서 읽어보시면 좋을 것 같습니다.
>

`@TransactionalEventListener`는 이벤트 리스너를 위한 어노테이션이지만, 저는 트랜잭션 분리에 관심이 있었기 때문에 왜 `AFTER_COMMIT` 속성을 가질 때는 `REQUIRED` 전파 속성을 갖는 트랜잭션의 커밋이 불가능한지가 궁금해졌습니다.

결론부터 이야기하자면, `AFTER_COMMIT`의 실행 시점이 물리 트랜잭션을 commit하고, connection을 unbind하는 시점 사이에 있기 때문입니다. 물리 트랜잭션의 커밋 로직은 다음과 같습니다.

1. 물리 트랜잭션인 경우 DB에 커밋
2. `AFTER_COMMIT`에 해당하는 작업 수행 (이벤트 리스너 호출)
3. connection 반납

1번을 보면 ‘물리 트랜잭션인 경우’에만 DB에 커밋한다고 되어있습니다.

기존 트랜잭션이 존재하는 경우 기존 트랜잭션에 참여하는 `REQUIRED` 전파 속성의 트랜잭션은 실제로 DB에 커밋하는 코드를 호출할 수 없습니다. 실제로 DB에 커밋하는 코드를 호출하는 조건은 `isNewTransaction()`이 true인 경우만 해당하는데, isNewTransaction은 새로운 connection을 가져와 물리 트랜잭션을 생성할 때 true로 변경되기 때문입니다. 즉, 기존 트랜잭션에 참여하는 논리 트랜잭션의 경우에는 `commit()`을 호출하더라도 커밋하는 시점에 실제로 DB에 커밋하는 코드를 호출할 수 없게되는 것입니다.

정리하자면 트랜잭션 커밋이 발생할 때 실제 DB에 커밋하는 메서드를 호출하기 위해서는 논리 트랜잭션이 아닌 새로운 물리 트랜잭션을 생성하거나, 아니면 물리 트랜잭션이 커밋되기 전에 커밋하고자 하는 부분을 모두 영속성 컨텍스트에 업데이트해두어 물리 트랜잭션이 커밋되는 시점에 함께 DB에 커밋될 수 있도록 해야합니다.

그런데 예제의 `@TransactionalEventListener`는 `REQUIRED` 전파 속성을 갖는 논리 트랜잭션이기에 DB에 커밋하는 코드를 호출할 수 없습니다. 따라서 변경 내역을 DB에 반영하기 위해서는 물리 트랜잭션이 커밋되기 전 영속성 컨텍스트에 값을 모두 변경해두고, 물리 트랜잭션이 DB에 커밋될 때 함께 커밋될 수 있도록 하는 방법밖에 없습니다. 하지만 `@TransactionalEventListener`의 기본 속성은 `AFTER_COMMIT`이기 때문에 물리 트랜잭션이 실행되고 난 이후에 동작하게 되어 이벤트 리스너 수행이 완료된 시점에서 실행 가능한 코드는 3번 connection 반납 뿐입니다.

이러한 이유로 인해 `REQUIRED` 전파 속성을 갖는 `@TransactionalEventListener` 메서드는 DB에 쓰기 작업이 불가능해지는 결론으로 이어지게된 것입니다.

### 코드로 확인하기

조금 더 깊게 이해하기 위해 스프링 트랜잭션 커밋을 할 때의 동작 과정을 살펴보면 다음과 같습니다.

`processCommit()`을 호출하고 있고, `processCommit()`의 실행 순서를 간단히 살펴보면 다음과 같습니다.

- processCommit 코드

    ```java
    private void processCommit(DefaultTransactionStatus status) throws TransactionException {
        try {
            boolean beforeCompletionInvoked = false;
    
            try {
                boolean unexpectedRollback = false;
                this.prepareForCommit(status);
                this.triggerBeforeCommit(status);
                this.triggerBeforeCompletion(status);
                beforeCompletionInvoked = true;
                if (status.hasSavepoint()) {
                    if (status.isDebug()) {
                        this.logger.debug("Releasing transaction savepoint");
                    }
    
                    unexpectedRollback = status.isGlobalRollbackOnly();
                    status.releaseHeldSavepoint();
                } else if (status.isNewTransaction()) {
                    if (status.isDebug()) {
                        this.logger.debug("Initiating transaction commit");
                    }
    
                    unexpectedRollback = status.isGlobalRollbackOnly();
                    this.doCommit(status);
                } else if (this.isFailEarlyOnGlobalRollbackOnly()) {
                    unexpectedRollback = status.isGlobalRollbackOnly();
                }
    
                if (unexpectedRollback) {
                    throw new UnexpectedRollbackException("Transaction silently rolled back because it has been marked as rollback-only");
                }
            } catch (UnexpectedRollbackException var17) {
                this.triggerAfterCompletion(status, 1);
                throw var17;
            } catch (TransactionException var18) {
                if (this.isRollbackOnCommitFailure()) {
                    this.doRollbackOnCommitException(status, var18);
                } else {
                    this.triggerAfterCompletion(status, 2);
                }
    
                throw var18;
            } catch (Error | RuntimeException var19) {
                if (!beforeCompletionInvoked) {
                    this.triggerBeforeCompletion(status);
                }
    
                this.doRollbackOnCommitException(status, var19);
                throw var19;
            }
    
            try {
                this.triggerAfterCommit(status);
            } finally {
                this.triggerAfterCompletion(status, 0);
            }
        } finally {
            this.cleanupAfterCompletion(status);
        }
    
    }
    ```

1. 먼저 첫 번째 try-catch문에서는 커밋을 위한 일련의 과정이 수행됩니다. prepareForCommit(), triggerBeforeCommit(), triggerBeforeCompletion() 등 커밋을 수행하기 이전 선행되어야 하는 작업들을 수행합니다.
2. 그리고 두 번째 분기문인 `else if (status.isNewTransaction())`를 확인해보면, global rollback 여부를 확인하고, 비로소 `this.doCommit()`을 호출하게 됩니다. 이때 물리 트랜잭션에 해당하면 `isNewTransaction()`는 true가, 논리 트랜잭션에 해당하면 false가 반환됩니다.
   (해당 내용이 잘 이해가 가지 않는다면 [레오의 글](https://00h0.tistory.com/100)을 참고하시면 좋을 것 같습니다.)
3. `doCommit()`은 `AbstractPlatformTransactionManager`를 상속받은 클래스에서 구현해야 하며, 따라서 `AbstractPlatformTransactionManager`를 상속 받은 `JpaTransactionManager`의 `doCommit()`을 실행해 실제로 DB에 커밋하게 됩니다.
4. 마지막으로 실행한 트랜잭션의 `unexpectedRollback`을 확인해 롤백이 발생하지 않는다면 다음 try-catch문으로 넘어가게 됩니다.
5. 다음 try-catch문은 드디어 기다리던 `AFTER_COMMIT`가 실제로 실행되는 곳입니다. 메서드명만 봐도 직관적으로 알 수 있듯이 `triggerAfterCommit()`이 호출됩니다. 해당 메서드를 확인해보면 다음과 같습니다.

    ```java
    private void triggerAfterCommit(DefaultTransactionStatus status) {
        if (status.isNewSynchronization()) {
            TransactionSynchronizationUtils.triggerAfterCommit();
        }
    }
    ```

   `TransactionSynchronizationUtils` 의 `triggerAfterCommit()` 메서드를 호출하고 있습니다.

   `TransactionSynchronizationUtils.triggerAfterCommit()`을 확인해보면 다음과 같은 작업을 하고 있습니다.

    ```java
    public static void triggerAfterCommit() {
        invokeAfterCommit(TransactionSynchronizationManager.getSynchronizations());
    }
    
    public static void invokeAfterCommit(@Nullable List<TransactionSynchronization> synchronizations) {
        if (synchronizations != null) {
            Iterator var1 = synchronizations.iterator();
    
            while(var1.hasNext()) {
                TransactionSynchronization synchronization = (TransactionSynchronization)var1.next();
                synchronization.afterCommit();
            }
        }
    
    }
    ```

   이벤트를 발행 메서드에서 `publishEvent()`를 호출했을 때 이 `TransactionSynchronizationManager`에 발행한 이벤트에 대한 정보가 저장됩니다. 그리고 실제로 실행되지는 않다가 커밋이 완료되고 `afterCommit()`이 호출되었을 때 `TransactionSynchronizationManager`에서 event가 저장된 `synchronization`을 가져옵니다. 그리고 `synchronization.afterCommit();`을 통해 커밋 이후 실행될 작업을 수행하게 됩니다.

   그런데 디버깅을 해보면 실제로 `TransactionalEventListener`에 해당하는 synchronization의 구현체는 `TransactionalApplicationListenerSynchronization`이고, 해당 클래스의 `afterCommit()`메서드는 오버라이딩 되어있지 않습니다. 대신 `afterCompletion()`을 오버라이딩한 메서드에서 afterCommit 속성을 갖는 경우 메서드를 실행시키는 코드가 있네요!

    ```java
    public void afterCompletion(int status) {
        TransactionPhase phase = this.listener.getTransactionPhase();
        if (phase == TransactionPhase.AFTER_COMMIT && status == 0) { // TransactionalEventListener의 기본 phase는 AFTER_COMMIT, status == 0 : 트랜잭션이 커밋된 상태
            this.processEventWithCallbacks();
        } else if (phase == TransactionPhase.AFTER_ROLLBACK && status == 1) {
            this.processEventWithCallbacks();
        } else if (phase == TransactionPhase.AFTER_COMPLETION) {
            this.processEventWithCallbacks();
        }
    }
    ```

   아무튼 결론은 `AFTER_COMMIT`에 해당하는 메서드를 실행하는 곳은 finally 블럭의 `this.triggerAfterCompletion(status, 0);` 내부에서 실행되는 것이라는 것을 눈으로 확인하게 되었습니다!

6. 마지막으로 가장 바깥쪽에 해당하는 try-catch-finally의 finally 블럭 내부를 보면 `cleanupAfterCompletion()`라는 작업을 수행하네요! 해당 [코드](https://github.com/spring-projects/spring-framework/blob/4560dc2818ae1d5e1bc5ceef89f1b6870700eb1f/spring-tx/src/main/java/org/springframework/transaction/support/AbstractPlatformTransactionManager.java#L1001)를 들여다보면 현재 트랜잭션이 물리 트랜잭션인지 확인하는 분기문이 존재하고, 물리트랜잭션이라면 `doCleanupAfterCompletion()`을 호출합니다. 드디어 가지고 있던 resource를 unbind하는 곳까지 왔습니다. 해당 코드는 `JpaTransactionManager`의 [메서드](https://github.com/spring-projects/spring-framework/blob/4560dc2818ae1d5e1bc5ceef89f1b6870700eb1f/spring-orm/src/main/java/org/springframework/orm/jpa/JpaTransactionManager.java#L585C17-L585C41)에서 확인하실 수 있습니다.

코드에서 본 것처럼 `AFTER_COMMIT`이자 `REQUIRED` 속성을 갖는 이벤트 리스너는 물리 트랜잭션이 커밋된 이후에 실행되고, 해당 메서드가 종료된 이후에는 더이상 DB에 커밋할 수 있는 작업이 남아있지 않고 connection을 반납하는 코드만 남아있는 것을 확인할 수 있었습니다.

### `@TransactionalEventListener`에서만 DB 쓰기 작업을 할 수 있는 방법

`@TransactionalEventListener`를 사용한다고 해도 DB 쓰기 작업이 불가능한 것은 이벤트 리스너가 기존 트랜잭션에 참여하는 논리 트랜잭션인 경우입니다. 즉, 이벤트 리스너에서 새로운 물리 트랜잭션을 열어주는 경우에는 얼마든지 DB에 커밋이 가능해진다는 것을 의미합니다.

방법도 간단합니다. 앞서 언급한 것처럼 `Propagation.REQUIRES_NEW`를 통해 새로운 물리 트랜잭션을 열어주거나, `@Async`를 사용해 스레드를 분리하여 트랜잭션을 분리해주면 됩니다.

하지만 이전의 방식과 약간의 차이점은 존재합니다.

### `@TransactionalEventListener` + `REQUIRES_NEW` 전파 속성

`AFTER_COMMIT`의 실행 시점은 기존 트랜잭션이 커밋된 이후, 그리고 connection을 반납하기 전입니다. 즉, 이벤트 리스너를 실행하는 시점에는 아직 connection이 반납되지 않은 상태입니다. 따라서 `Propagation.REQUIRES_NEW`를 통해 새로운 connection을 할당받게 되는 경우 기존의 방식과 같이 데드락이 발생할 위험이 있습니다. 이때 `@Async`가 해결 방법이 됩니다.

### `@TransactionalEventListener` + `@Async`

`@Async`를 사용하는 것은 비동기로 실행된다는 것을 의미하기 때문에 순서에 주의해야 한다고 언급했습니다. 그런데 `@TransactionalEventListener`의 기본 속성은 `AFTER_COMMIT`입니다. 즉, 기존 트랜잭션 커밋이 완료된 시점에 실행되는 메서드입니다. 따라서 `@Async`를 통해 스레드가 분리되는 시점 또한 기존 트랜잭션 커밋이 완료된 이후가 됩니다. 따라서 원하던대로 기존 트랜잭션이 커밋된 이후 수행되는 순서를 유지할 수 있으면서도 안전하게 트랜잭션을 분리할 수 있는 것입니다.

## 이 글을 쓰게된 목적

스프링 이벤트로 의존성을 분리해야겠다는 결정을 내린 순간에는 스프링 이벤트에 대한 지식이 전무한 상태였습니다. 그래서 이벤트 리스너, 이벤트 발행 메서드, 이벤트 DTO가 어느 패키지에 포함되어있어야 하는지 궁금했고, 다른 크루들이 사용한 이벤트 리스너를 참고하다보니 모든 크루들의 이벤트 리스너 형태가 달랐습니다.

마찬가지로 트랜잭션을 분리하고 순서를 보장하기 위해 구글링 하는 과정에서도 각자의 비즈니스 로직이 다른 만큼 추천하는 이벤트 리스너 사용법이 모두 달랐고, 또 이벤트 리스너와 트랜잭션 분리를 위해 사용한 방법으로 인해 발생하는 문제점들도 서로 상이했습니다.

이벤트 리스너를 담당한 만큼 현재 우리 서비스의 비즈니스 로직에 적절한 어노테이션을 사용하고 있는 것인지 궁금했고, 이 궁금증을 해소하고자 여러가지 실험을 해본 뒤 이 글을 작성하게 되었습니다.

## 결론: 그래서 어떤 이벤트 리스너를 사용하면 되나요?

언제나 그렇듯 비즈니스 규칙에 적절한 이벤트 리스너와 트랜잭션 전파 속성을 사용하면 됩니다. 그리고 아래는 제가 학습한 내용을 바탕으로 정한 이벤트 리스너와 트랜잭션 분리를 위한 어노테이션 사용 기준입니다.

1. 이벤트 발행 메서드와 이벤트 리스너가 하나의 트랜잭션으로 묶여야 하는 경우

   `@EventListener` + `@Transactional(propagation = Propagation.REQUIRED` 사용


1. 이벤트 발행 메서드와 이벤트 리스너의 실행 순서가 보장되지 않아도 되고, 트랜잭션 분리만 필요한 경우

   `@EventListener` + `@Async` 사용

2. 이벤트 발행 메서드 → 이벤트 리스너의 순서가 보장되어야 하는 경우
   또는 이벤트 발행 메서드와 이벤트 리스너의 트랜잭션을 분리해야 하는데, 이벤트 리스너에서 DB 쓰기 작업이 불필요한 경우

   `@TransactionalEventListener`


1. 이벤트 발행 메서드 →  이벤트 리스너의 순서가 보장되어야 하고, 이벤트 리스너에서 DB 쓰기 작업이 필요한 경우

   `@TransactionalEventListener` + `@Async`


## 마무리

단순히 트랜잭션을 분리하고 의존성을 분리하려는 목적으로 `@TransactionalEventListener`를 사용했고, 트랜잭션 순서를 보장하기 위한 방법을 찾아보는 과정에서 해당 어노테이션이 붙은 메서드의 동작 원리를 학습하게 되었습니다. 그런데 결과적으로 스프링 트랜잭션의 동작 원리를 이해하지 못해 `@TransactionalEventListener`의 동작 원리를 이해하는 데 어려움이 있었던 것을 보면 스프링의 트랜잭션이 스프링에서 얼마나 중요한 개념인지 체감하게 되었던 것 같습니다.

스프링이 굉장히 방대한 기능을 가진 만큼 모든 스프링의 모든 기능을 이해하거나 미리 숙지하고 사용하기는 어려울 것입니다. 하지만 지금처럼 해결해야 하는 문제를 마주했을 때 최소한 그 사용하는 기능은 제대로 파악하고자 하는 의지와 호기심을 가지고 하나씩 공부해나가다보면 언젠가 스프링과 조금 더 친해질 수 있지 않을까 하는 기대를 갖게 해준 값진 경험이 되었습니다.
